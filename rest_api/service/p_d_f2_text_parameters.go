// Code generated by go-swagger; DO NOT EDIT.

package service

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewPDF2TextParams creates a new PDF2TextParams object
// with the default values initialized.
func NewPDF2TextParams() PDF2TextParams {

	var (
		// initialize parameters with default values

		encDefault = string("UTF-8")
	)

	return PDF2TextParams{
		Enc: &encDefault,
	}
}

// PDF2TextParams contains all the bound params for the p d f2 text operation
// typically these are obtained from a http.Request
//
// swagger:parameters PDF2Text
type PDF2TextParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*output bounding box for each word and page size to html. Sets `htmlmeta`
	  In: query
	*/
	Bbox *bool
	/*like `bbox` but with extra layout bounding box data.  Sets `htmlmeta`
	  In: query
	*/
	BboxLayout *bool
	/*how much spacing we allow after a word before considering adjacent text to be a new column, as a fraction of the font size (default is 0.7, old releases had a 0.3 default)
	  In: query
	*/
	Colspacing *float64
	/*use the crop box rather than media box
	  In: query
	*/
	Cropbox *bool
	/*output text encoding name
	  In: query
	  Default: "UTF-8"
	*/
	Enc *string
	/*output end-of-line convention (unix, dos, or mac)
	  In: query
	*/
	Eol *string
	/*first page to convert
	  In: query
	*/
	F *int64
	/*assume fixed-pitch (or tabular) text, in fp
	  In: query
	*/
	Fixed *int64
	/*height of crop area in pixels (default is 0)
	  In: query
	*/
	H *int64
	/*generate a simple HTML file, including the meta information
	  In: query
	*/
	Htmlmeta *bool
	/*last page to convert
	  In: query
	*/
	L *int64
	/*maintain original physical layout
	  In: query
	*/
	Layout *bool
	/*discard diagonal text
	  In: query
	*/
	Nodiag *bool
	/*owner password (for encrypted files)
	  In: query
	*/
	Opw *string
	/*insert page breaks between pages
	  In: query
	*/
	Pgbrk *bool
	/*resolution, in DPI (default is 72)
	  In: query
	*/
	R *int64
	/*keep strings in content stream order
	  In: query
	*/
	Raw *bool
	/*generate a simple TSV file, including the meta information for bounding boxes
	  In: query
	*/
	Tsv *bool
	/*user password (for encrypted files)
	  In: query
	*/
	Upw *string
	/*width of crop area in pixels (default is 0)
	  In: query
	*/
	W *int64
	/*x-coordinate of the crop area top left corner
	  In: query
	*/
	X *int64
	/*y-coordinate of the crop area top left corner
	  In: query
	*/
	Y *int64
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewPDF2TextParams() beforehand.
func (o *PDF2TextParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qBbox, qhkBbox, _ := qs.GetOK("bbox")
	if err := o.bindBbox(qBbox, qhkBbox, route.Formats); err != nil {
		res = append(res, err)
	}

	qBboxLayout, qhkBboxLayout, _ := qs.GetOK("bbox-layout")
	if err := o.bindBboxLayout(qBboxLayout, qhkBboxLayout, route.Formats); err != nil {
		res = append(res, err)
	}

	qColspacing, qhkColspacing, _ := qs.GetOK("colspacing")
	if err := o.bindColspacing(qColspacing, qhkColspacing, route.Formats); err != nil {
		res = append(res, err)
	}

	qCropbox, qhkCropbox, _ := qs.GetOK("cropbox")
	if err := o.bindCropbox(qCropbox, qhkCropbox, route.Formats); err != nil {
		res = append(res, err)
	}

	qEnc, qhkEnc, _ := qs.GetOK("enc")
	if err := o.bindEnc(qEnc, qhkEnc, route.Formats); err != nil {
		res = append(res, err)
	}

	qEol, qhkEol, _ := qs.GetOK("eol")
	if err := o.bindEol(qEol, qhkEol, route.Formats); err != nil {
		res = append(res, err)
	}

	qF, qhkF, _ := qs.GetOK("f")
	if err := o.bindF(qF, qhkF, route.Formats); err != nil {
		res = append(res, err)
	}

	qFixed, qhkFixed, _ := qs.GetOK("fixed")
	if err := o.bindFixed(qFixed, qhkFixed, route.Formats); err != nil {
		res = append(res, err)
	}

	qH, qhkH, _ := qs.GetOK("h")
	if err := o.bindH(qH, qhkH, route.Formats); err != nil {
		res = append(res, err)
	}

	qHtmlmeta, qhkHtmlmeta, _ := qs.GetOK("htmlmeta")
	if err := o.bindHtmlmeta(qHtmlmeta, qhkHtmlmeta, route.Formats); err != nil {
		res = append(res, err)
	}

	qL, qhkL, _ := qs.GetOK("l")
	if err := o.bindL(qL, qhkL, route.Formats); err != nil {
		res = append(res, err)
	}

	qLayout, qhkLayout, _ := qs.GetOK("layout")
	if err := o.bindLayout(qLayout, qhkLayout, route.Formats); err != nil {
		res = append(res, err)
	}

	qNodiag, qhkNodiag, _ := qs.GetOK("nodiag")
	if err := o.bindNodiag(qNodiag, qhkNodiag, route.Formats); err != nil {
		res = append(res, err)
	}

	qOpw, qhkOpw, _ := qs.GetOK("opw")
	if err := o.bindOpw(qOpw, qhkOpw, route.Formats); err != nil {
		res = append(res, err)
	}

	qPgbrk, qhkPgbrk, _ := qs.GetOK("pgbrk")
	if err := o.bindPgbrk(qPgbrk, qhkPgbrk, route.Formats); err != nil {
		res = append(res, err)
	}

	qR, qhkR, _ := qs.GetOK("r")
	if err := o.bindR(qR, qhkR, route.Formats); err != nil {
		res = append(res, err)
	}

	qRaw, qhkRaw, _ := qs.GetOK("raw")
	if err := o.bindRaw(qRaw, qhkRaw, route.Formats); err != nil {
		res = append(res, err)
	}

	qTsv, qhkTsv, _ := qs.GetOK("tsv")
	if err := o.bindTsv(qTsv, qhkTsv, route.Formats); err != nil {
		res = append(res, err)
	}

	qUpw, qhkUpw, _ := qs.GetOK("upw")
	if err := o.bindUpw(qUpw, qhkUpw, route.Formats); err != nil {
		res = append(res, err)
	}

	qW, qhkW, _ := qs.GetOK("w")
	if err := o.bindW(qW, qhkW, route.Formats); err != nil {
		res = append(res, err)
	}

	qX, qhkX, _ := qs.GetOK("x")
	if err := o.bindX(qX, qhkX, route.Formats); err != nil {
		res = append(res, err)
	}

	qY, qhkY, _ := qs.GetOK("y")
	if err := o.bindY(qY, qhkY, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindBbox binds and validates parameter Bbox from query.
func (o *PDF2TextParams) bindBbox(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("bbox", "query", "bool", raw)
	}
	o.Bbox = &value

	return nil
}

// bindBboxLayout binds and validates parameter BboxLayout from query.
func (o *PDF2TextParams) bindBboxLayout(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("bbox-layout", "query", "bool", raw)
	}
	o.BboxLayout = &value

	return nil
}

// bindColspacing binds and validates parameter Colspacing from query.
func (o *PDF2TextParams) bindColspacing(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("colspacing", "query", "float64", raw)
	}
	o.Colspacing = &value

	return nil
}

// bindCropbox binds and validates parameter Cropbox from query.
func (o *PDF2TextParams) bindCropbox(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("cropbox", "query", "bool", raw)
	}
	o.Cropbox = &value

	return nil
}

// bindEnc binds and validates parameter Enc from query.
func (o *PDF2TextParams) bindEnc(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewPDF2TextParams()
		return nil
	}
	o.Enc = &raw

	return nil
}

// bindEol binds and validates parameter Eol from query.
func (o *PDF2TextParams) bindEol(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Eol = &raw

	if err := o.validateEol(formats); err != nil {
		return err
	}

	return nil
}

// validateEol carries on validations for parameter Eol
func (o *PDF2TextParams) validateEol(formats strfmt.Registry) error {

	if err := validate.EnumCase("eol", "query", *o.Eol, []interface{}{"unix", "dos", "mac"}, true); err != nil {
		return err
	}

	return nil
}

// bindF binds and validates parameter F from query.
func (o *PDF2TextParams) bindF(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("f", "query", "int64", raw)
	}
	o.F = &value

	return nil
}

// bindFixed binds and validates parameter Fixed from query.
func (o *PDF2TextParams) bindFixed(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("fixed", "query", "int64", raw)
	}
	o.Fixed = &value

	return nil
}

// bindH binds and validates parameter H from query.
func (o *PDF2TextParams) bindH(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("h", "query", "int64", raw)
	}
	o.H = &value

	return nil
}

// bindHtmlmeta binds and validates parameter Htmlmeta from query.
func (o *PDF2TextParams) bindHtmlmeta(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("htmlmeta", "query", "bool", raw)
	}
	o.Htmlmeta = &value

	return nil
}

// bindL binds and validates parameter L from query.
func (o *PDF2TextParams) bindL(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("l", "query", "int64", raw)
	}
	o.L = &value

	return nil
}

// bindLayout binds and validates parameter Layout from query.
func (o *PDF2TextParams) bindLayout(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("layout", "query", "bool", raw)
	}
	o.Layout = &value

	return nil
}

// bindNodiag binds and validates parameter Nodiag from query.
func (o *PDF2TextParams) bindNodiag(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("nodiag", "query", "bool", raw)
	}
	o.Nodiag = &value

	return nil
}

// bindOpw binds and validates parameter Opw from query.
func (o *PDF2TextParams) bindOpw(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Opw = &raw

	return nil
}

// bindPgbrk binds and validates parameter Pgbrk from query.
func (o *PDF2TextParams) bindPgbrk(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("pgbrk", "query", "bool", raw)
	}
	o.Pgbrk = &value

	return nil
}

// bindR binds and validates parameter R from query.
func (o *PDF2TextParams) bindR(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("r", "query", "int64", raw)
	}
	o.R = &value

	return nil
}

// bindRaw binds and validates parameter Raw from query.
func (o *PDF2TextParams) bindRaw(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("raw", "query", "bool", raw)
	}
	o.Raw = &value

	return nil
}

// bindTsv binds and validates parameter Tsv from query.
func (o *PDF2TextParams) bindTsv(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("tsv", "query", "bool", raw)
	}
	o.Tsv = &value

	return nil
}

// bindUpw binds and validates parameter Upw from query.
func (o *PDF2TextParams) bindUpw(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.Upw = &raw

	return nil
}

// bindW binds and validates parameter W from query.
func (o *PDF2TextParams) bindW(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("w", "query", "int64", raw)
	}
	o.W = &value

	return nil
}

// bindX binds and validates parameter X from query.
func (o *PDF2TextParams) bindX(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("x", "query", "int64", raw)
	}
	o.X = &value

	return nil
}

// bindY binds and validates parameter Y from query.
func (o *PDF2TextParams) bindY(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("y", "query", "int64", raw)
	}
	o.Y = &value

	return nil
}
